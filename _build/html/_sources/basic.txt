======
 基礎
======

.. contents:: Contents
   :depth: 2

記述と実行
==========

Groovyでは、メソッドやクラスのブロックの外側に、実行文を記述できる。
（これを「スクリプト」という）

スクリプトは、コンパイル時には自動生成されたmainメソッドから呼ばれる。
従って、Javaとは異なり、mainメソッドを記述する必要はない。

コマンドライン引数は、 ``args`` という暗黙定義されたString配列から
取得できる。

記述したソースコードは、そのままgroovyインタプリタで実行できる。
また、 ``groovyc`` コマンドで、classファイルにコンパイルすることもできる。


ライブラリのインポート
======================

Javaと同様、外部のライブラリを呼び出すにはimport文で使用するパッケージまたはクラスを宣言する。
Groovyでは、以下のimportは暗黙的に宣言されており、記述を省略できる。

* java.lang.*
* java.io.*
* java.net.*
* java.util.*
* groovy.lang.*
* groovy.util.*
* java.math.BigDecimal
* java.math.BigInteger


Groovy JDK
==========

Groovyで標準的に利用するクラスは、JavaAPIに含まれているものをそのまま利用するが、
各クラスにはGroovy独自のメソッドやプロパティが追加され、より高機能になっている。

例えば、Groovyにおけるリストは、Javaと同様java.util.List型となるが、Javaにはない
高階関数によるフィルタ、各要素への関数適用、等のメソッドが利用できる。

Groovy JDKで拡張されているクラスのAPIリファレンスは以下。

http://groovy.codehaus.org/groovy-jdk/


Groovy の文法について
=====================

GroovyはJavaの文法に似せており、大体の場合において、JavaのコードはそのままGroovyインタプリタに読ませても動作する。

一方で、動的型付け言語らしい簡略記法や、第一級関数（クロージャ）のような仕組みを取り入れており、
Javaよりも大幅に少ないコード量で同様の機能が実現できるようになっている。


括弧、セミコロンの省略
----------------------

Groovyでは、一行に複数の文を書かない限り、文末のセミコロンは省略できる。
また、メソッドの引数リストを括る括弧も、構文解析に支障がない限りは省略できる。

.. code-block:: groovy

   // 以下は全て同じ意味
   println("hello");
   println("hello")
   println "hello"


型記述の省略
------------

Groovyでは、型の記述はほとんど省略できる。この場合は多くの動的型付け言語と同様、
静的な型チェックは行われない。(Scalaのような型推論によるチェックは行われないので注意)

Java同様の型記述を行う場合は、型チェックが行われる。

なお、Javaで書かれたのメソッドをオーバーライドする場合、戻り値の型を明記し、
継承元のメソッドと一致させないとコンパイルエラーとなる。

.. code-block:: groovy

   // 変数宣言の例
   def a = "test"
   Integer b   // この場合、bに文字列等を代入しようとするとエラーとなる。

   // メソッド宣言の例(引数と戻り値の型を省略）
   def hello(name) {
     println("hello " + name)
   }


リテラル、変数、型
==================

プリミティブ型
--------------

Groovyでは、原則として、プリミティブ型がそのまま使われることはなく、
必ず参照型（ラッパー型）として扱われる。
(たとえばint型で変数を定義しても、その変数はInteger型として扱われる)


ジェネリクス
------------

Javaのジェネリクスは、Groovyで記述してもエラーにはならないが、型チェックは行われない。
ただし、コンパイル後のclassファイルには型情報が含まれるため、Javaから呼び出す場合は
コンパイル時に型チェックが行われる。


小数リテラル
------------

小数リテラルは、接尾詞を指定しない限りBigDecimal型 (固定小数点数)として扱われる。

浮動小数点数として扱いたい場合は、接尾詞 ``f`` （Float型）または ``d`` （Double型）を
付加する。


文字列リテラル
--------------

文字列リテラルを記述する際に使用する引用符は、Javaと意味が異なる。

.. code-block:: groovy
   
   // シングルクォート:通常の文字列(Javaと異なり、char型リテラルではない)
   def str1 = 'abc'

   // 「as char」を付記するとchar型リテラルになる
   def char1 = 'a' as char

   // ダブルクォート:「$変数名」または「${式}」が含まれる場合は評価結果の値で置換される
   def str2 = "a $str1"          // 'a abc' と等価

   // スラッシュ: 「\」がエスケープ文字として扱われない以外はダブルクォートと同様
   def str3 = /a\bcd/            // 'a\\bcd' と等価

   // 三連シングルクォート: 改行を含む文字列
   def str4 = '''line1
   line2'''

   // 三連ダブルクォート: 改行を含む文字列($の置換あり)
   def str5 = """line1 $str1
   line2"""


なお、ダブルクォートやスラッシュで記述される文字列リテラルはGString型となる。
「$変数名」や「${式}」が変化する(Immutableでない) 場合、GStringはString型として評価された
時点で値が確定する。

.. code-block:: groovy

   def a = "init"
   def b = "$a"
   a = "change"
   println b   // change と表示される


コレクションリテラル
--------------------

以下の記述で配列オブジェクトやコレクションオブジェクトが生成される。

.. code-block:: groovy

   def a = [1, 2, 3, 4]          // 配列
   def l = [1, 2, 3, 4] as List  // java.util.Listインスタンス


Javaと同様に ``Integer[] l = new Integer[] {1, 2, 3, 4}`` のような記述も可能だが、
角括弧による配列リテラルは、変数宣言以外でも記述可能。

配列リテラルのあとに ``as List`` を付加することで、List (java.util.ArrayList)の
インスタンスを取得できる。

Map（連想配列）のリテラルは以下のように記述する。(java.util.LinkedHashMapインスタンスが得られる)

.. code-block:: groovy

   def newMap = [key1 : value1, key2 : value2]


マルチ代入
----------

配列やリストの内容を、一度に複数の変数に展開・代入ができる。

.. code-block:: groovy

   def (a, b) = [1, 2] // aに1, bに2 が代入される


変数の数がリストの要素数より多い場合、余った変数にはnullが代入される。


バインディング変数とローカル変数
--------------------------------

スクリプト内に限り、型名や ``def`` キーワードを付けずに変数宣言・初期化を行う事ができる。
このようにして宣言した変数は *バインディング変数* となる。

対して、メソッドやクラス定義内、クロージャ内で定義する変数をローカル変数と呼ぶ。
また、スクリプト内であっても、型名や ``def`` キーワードで宣言した変数はローカル変数と呼ぶ。

ソースコードの見た目上、スクリプトはクラスやメソッドといった構造の最上位に見えるが、
スクリプト内で定義したローカル変数は、クラスやメソッド内からはアクセス出来ない。
(スクリプトのコードはコンパイル時に内部でprivateメソッドに括られるため)

このため、クラスやメソッド内からも参照できるグローバルスコープの変数を定義する場合は
バインディング変数として定義する必要がある。

.. code-block:: groovy
   
   def a = 1        // ローカル変数
   b = 2            // バインディング変数
   
   def func() {
     b = 3          // 最初に宣言したバインディング変数が書き換わる
     a = 2          // エラー。関数外で宣言されたローカル変数 a にはアクセス出来ない
   }

演算子
======


比較演算子
----------

Groovyにおいては、 ``==`` を使った比較では、内部的にequalsメソッドが呼び出されるため、
インスタンスが同一かどうか（参照先が同一かどうか）で判定するJavaとは動作が異なることに注意。

例えば、２つの文字列が同一かどうかの比較も、 s1.equals(s2) の代わりに s1 == s2 と書ける。

また、不等号で比較する際も、内部でcompareToメソッドが呼び出される。
このため、たとえオリジナルのクラスであっても、 java.lang.Comparableインタフェースさえ
実装していれば、不等号による比較を行えるようになる。


nullセーフナビゲーション
------------------------

通常、オブジェクトのフィールドやメソッドにアクセスする場合は ``a.b`` のように
記述するが、 ``a?.b`` のように、 ``?.`` 演算子を使用すると、aがnullであっても
NullPointerExceptionを発生せず、単にnullを返す。


条件演算子（三項演算子、Elvis演算子）
-------------------------------------

条件演算子 ``a ? b : c`` は、Javaにおいては条件節にboolean型以外の値を指定すると
コンパイルエラーとなるが、Groovyではbooleanである必要がない（そもそも型チェックされない）。
boolean以外の場合、null、数値の0、長さ0の文字列などがfalse扱いとなる。

また、条件節とtrueの場合の評価結果が同じになる（例えば ``a ? a : b`` )ような場合、
``a ?: b`` という略記が可能。(これをElvis演算子と呼ぶ)


リスト展開演算子
----------------

ある配列やリストの中に、別の配列やリストをフラットに展開したい場合、
リスト展開演算子 ``*`` を用いる。

.. code-block:: groovy

   def a = [3, 4, 5]
   def b = [1, 2, *a, 6]   // aがb内に展開されて [1, 2, 3, 4, 5, 6] となる


展開ドット演算子
----------------

例えば、Stringの配列があった場合、以下のような構文で、配列内の各要素の長さを
配列として取得することができる。

.. code-block:: groovy

   def strAry = ["abcd","efg","hijk"]
   def sizeArray = strAry*.size() 
       // [strAry[0].size(), strAry[1].size(), strAry[2].size()] と同じ


このような演算子 ``*.`` を「展開ドット演算子」と呼ぶ。


包含演算子
----------

SQLのIN演算子のようなもの。右辺の値が、左辺の配列やリストに含まれていればtrueを返す。

.. code-block:: groovy

   def contains = 'a' in ['a','b','c']  // true


また、左辺にPattern型（正規表現を扱う型）の値を記述すれば、正規表現にマッチしたかどうか
判定できる。

.. code-block:: groovy

   def match = "abcd" in ~/.*bc.*/  // true (~/ ... / は、Pattern型リテラル)


包含演算子は、左辺のオブジェクトの isCase メソッドを呼び出す 
( ``a in b`` は ``b.isCase(a)`` と等価) ので、独自クラスであっても、
isCaseメソッドを実装すれば、包含演算子による演算が可能。


演算子オーバーロード
------------------------

参考：http://www.ibm.com/developerworks/jp/java/library/j-pg10255/

Java では、プリミティブ型以外の数値型(BigDecimal等)に対しては通常の数学的演算子(+,* など)が
使用できず、add や multply 、equals などのメソッドを使用する必要があるが、
Groovy では BigDecimal や BigInteger などの数値型でも数学的演算子が利用可能。

また、演算子や記号は以下のようなメソッドに対応しており、対応するメソッドを実装しておけば、
任意のクラスで数学的演算子による演算が可能になる。

============== =======================
演算子         メソッド
============== =======================
a + b          a.plus(b)
a - b          a.minus(b)
a * b          a.multiply(b)
a / b          a.divide(b)
a ** b         a.power(b)
a % b          a.mod(b)
a | b          a.or(b)
a & b          a.and(b)
a ^ b          x.xor(b)
a++ or ++a     a.next()
a-- or --a     a.previous()
a << b	       a.leftShift(b)
a >> b	       a.rightShift(b)
a >>> b	       a.rightShiftUnsignd(b)
a[b]           a.getAt(b)
a[b] = c       a.putAt(b, c)
a in b         b.isCase(a)
a as b         a.asType(b)
~a             a.bitwiseNegate()
-a             a.negative()
+a             a.positive()
a == b         a.equals(b)
a <=> b        a.compareTo(b)
a(任意の引数)  a.call(任意の引数)
============== =======================

.. code-block:: groovy

   class Hoge { 
     int n

     Hoge plus(Hoge a) {
       return new Hoge(n: this.n + a.n)
     }

     String toString(){
       return n.toString()
     }
   }

   def one = new Hoge(n: 1)
   def two = new Hoge(n: 2)

   println one + two  // "3"と出力される


制御構造
========

制御構造の構文もJavaと同じ物が使用出来るが、Groovy独自のものを以下に挙げる。

繰り返し
--------

Javaの通常のfor文、拡張for文の両方が利用できる。Groovyでは ``0..10`` のような記法で
数値のリストを生成できるため、これを利用して以下の様な記述ができる。

.. code-block:: groovy

   for (int i: 0..10) {
     // iが0から10まで繰り返される
   }


また、Groovy独自の構文として以下の形式が利用できる。

.. code-block:: groovy

   for (i in 0..10) {
     // iが0から10まで繰り返される
   }


どちらも同じ動作になるが、後者はループ変数の宣言が不要。
（前者の場合は、変数が事前に宣言されているか、for文の中で型もしくはdefキーワードをつけて
宣言しなければいけない）


switch-case
-----------

switch-caseは、Javaのものと比べて多機能になっている。
一般的には、caseのあとの条件に指定されたオブジェクトのisCaseメソッドを呼び出し、
trueが帰れば、直後の処理を実行するようになっている。

isCaseメソッドは数値や列挙型(enum)はもちろん、文字列、配列やリスト、
Pattern（正規表現オブジェクト）に用意されているので、
これらはそのままswitch-caseの条件として利用できる。

.. code-block:: groovy

   switch (x) {
     case "abc":        // xが文字列"abc"に等しい場合
       // 処理
       break

     case ~/.*bc.*/     // xが正規表現「.*bc.*」にマッチする場合
       // 処理
       break

     case ["abc","def","kkk"]  //配列の要素いずれかと等しい場合
       // 処理
       break

     case 1..10          //1～10の範囲に含まれる場合
       // 処理
       break

     default:
       // デフォルト処理
   }


return文
--------

関数やメソッドの末尾にあるreturn文については、 ``return`` キーワードを省略できる。

Groovyでは、 ``return`` キーワードの有無にかかわらず、最後に評価された式の結果が暗黙的に
戻り値として返される。

``return`` を明示的に記述した場合、Java同様、関数やメソッドの動作を途中で打ち切る効果を持つ。


assert文
--------

Groovyの ``assert`` は、実行時オプションで無効化できない。

また、 ``assert`` の条件に違反が合った場合は、 ``PowerAssertionError`` 例外が発生し、
Javaの ``AssertionError`` に比べて詳細なエラーメッセージが出力される。


例外
----

Groovyでは、チェック例外を持つメソッドを呼ぶ場合でも、必ずしも例外処理を記述する必要はない。
この場合、呼び出し先のメソッドでチェック例外が発生すると、更に上流へ同じ例外をそのままthrowする。

また、メソッド宣言時に ``throws`` でチェック例外を明示する場合、Groovy内では意味が無いが、
コンパイル後にJavaから呼び出す場合は、例外処理チェックが行われる。

catch文に記述する例外変数名に型を記述しない場合、暗黙的に ``java.lang.Exception`` 型で
catchする。

.. code-block:: groovy

   try {
     // 例外を発生する処理
   } catch (e) {  // catch(Exception e) と同じ
     //例外処理
   }
